{
  "hash": "fe8657b9ba3e6b4c3fe22bc182223c31",
  "result": {
    "engine": "knitr",
    "markdown": "# Cleaning Data {#sec-chapter}\n\n\n\n\n\n\n\n\n\n\n\n> ### Learning Objectives {.unnumbered}\n>\n> * Merge multiple datasets effectively with joins.\n> * Clean, organize, and recode variables.\n> * Handle and process date data.\n\n## Merging Data Sets with Joins\n\nLet's say we have two data sets: state names, and state abbreviations. Now we want to merge them into a data frame so that the state names and abbreviations are in the same row. \n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nhead(names)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   state_name\n#> 1    Alabama\n#> 2     Alaska\n#> 3    Arizona\n#> 4   Arkansas\n#> 5 California\n#> 6   Colorado\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(abbs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   state_abb\n#> 1        AK\n#> 2        AL\n#> 3        AR\n#> 4        AZ\n#> 5        CA\n#> 6        CO\n```\n\n\n:::\n:::\n\n\n\n\n\nWe might be tempted to simply merge the two data sets using `bind_cols()`, like this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nresult <- bind_cols(names, abbs)\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   state_name state_abb\n#> 1    Alabama        AK\n#> 2     Alaska        AL\n#> 3    Arizona        AR\n#> 4   Arkansas        AZ\n#> 5 California        CA\n#> 6   Colorado        CO\n```\n\n\n:::\n:::\n\n\n\n\n\nWhile this _looks_ like it works, if you look closely, you'll see that the state abbreviations are all mixed up (e.g., Alabama and Alaska are swapped). \n\nThis is where joins come into play.\n\n::: {.callout-note}\n\nJoining is a way to combine two data sets based on a common variable.\n\n:::\n\nThere are three types of joins that we can utilize to properly merge data sets.\n\n1. `inner_join()`\n2. `left_join()` / `right_join()`\n3. `full_join()`\n\nWe'll take a look at the different joins applied to the `band_members` & `band_instruments` data sets.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 2\n#>   name  band   \n#>   <chr> <chr>  \n#> 1 Mick  Stones \n#> 2 John  Beatles\n#> 3 Paul  Beatles\n```\n\n\n:::\n\n```{.r .cell-code}\nband_instruments\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 2\n#>   name  plays \n#>   <chr> <chr> \n#> 1 John  guitar\n#> 2 Paul  bass  \n#> 3 Keith guitar\n```\n\n\n:::\n:::\n\n\n\n\n\n### `inner_join()`\n\nIn inner joins, only the rows that have a match on the common variable are kept. This gif illustrates the inner join:\n\n<center>\n<img src=\"images/inner_join.gif\">\n</center>\n\nApplied to our example, we get:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    inner_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 2 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 John  Beatles guitar\n#> 2 Paul  Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\n### `full_join()`\n\nIn full joins, all rows from both data sets are kept. This gif illustrates the full join:\n\n<center>\n<img src=\"images/full_join.gif\">\n</center>\n\nApplied to our example, we get:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    full_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 4 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 Mick  Stones  <NA>  \n#> 2 John  Beatles guitar\n#> 3 Paul  Beatles bass  \n#> 4 Keith <NA>    guitar\n```\n\n\n:::\n:::\n\n\n\n\n\nNote here that `NA` values are introduced for the missing matches.\n\n### `left_join()`\n\nIn left joins, all rows from the left data set are kept. This gif illustrates the left join:\n\n<center>\n<img src=\"images/left_join.gif\">\n</center>\n\nApplied to our example, we get:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    left_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 Mick  Stones  <NA>  \n#> 2 John  Beatles guitar\n#> 3 Paul  Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\nHere we get an `NA` for Mick Stones as we don't know what instrument he plays (he is not in the `band_instruments` data set).\n\n### `right_join()`\n\nRight joins are just the opposite of left joins. All rows from the right data set are kept. This gif illustrates the right join:\n\n<center>\n<img src=\"images/right_join.gif\">\n</center>\n\nApplied to our example, we get:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    right_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 John  Beatles guitar\n#> 2 Paul  Beatles bass  \n#> 3 Keith <NA>    guitar\n```\n\n\n:::\n:::\n\n\n\n\n\n### We can also specify the joining variable name\n\nIf you don't specify the joining variable name, R will use the first variable name that appears in both data sets:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    left_join(band_instruments)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Joining with `by = join_by(name)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 Mick  Stones  <NA>  \n#> 2 John  Beatles guitar\n#> 3 Paul  Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\nHere you see the message `` Joining with `by = join_by(name)` ``, because R realized that the `name` variable appears in each dataset. \n\nWe can be more explicit by specifying the joining variable name, like this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n    left_join(\n        band_instruments,\n        by = 'name'\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 Mick  Stones  <NA>  \n#> 2 John  Beatles guitar\n#> 3 Paul  Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\nHere we get no message because we told R which variable to use to join.\n\n### What if the names differ?\n\nIf the matching column has a different name in each data frame, use `by = c(\"left_name\" = \"joining_name\")` to specify the correct joining name.\n\nFor example, in the two data frames below we have `name` in one of them and `artist` in the other. Since these don't match, R won't know which column to use by default to do the join. Here is how we can tell it that these two columns should be used for matching:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 2\n#>   name  band   \n#>   <chr> <chr>  \n#> 1 Mick  Stones \n#> 2 John  Beatles\n#> 3 Paul  Beatles\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_instruments2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 2\n#>   artist plays \n#>   <chr>  <chr> \n#> 1 John   guitar\n#> 2 Paul   bass  \n#> 3 Keith  guitar\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n  left_join(\n    band_instruments2,\n    by = c(\"name\" = \"artist\")\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   name  band    plays \n#>   <chr> <chr>   <chr> \n#> 1 Mick  Stones  <NA>  \n#> 2 John  Beatles guitar\n#> 3 Paul  Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can also just rename the joining variable before joining, like this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nband_members %>%\n  rename(artist = name) %>%\n  left_join(\n    band_instruments2,\n    by = \"artist\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 3 × 3\n#>   artist band    plays \n#>   <chr>  <chr>   <chr> \n#> 1 Mick   Stones  <NA>  \n#> 2 John   Beatles guitar\n#> 3 Paul   Beatles bass\n```\n\n\n:::\n:::\n\n\n\n\n\n## Variable Types and Names\n\n### Fixing Variable Types\n\n::: {.callout-important}\n\nAlways check variable types after reading in data!\n\n:::\n\nA lot of times variables get encoded into a data type that is not what you would want after reading in an external data file. Take a look at this data set:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwind <- read_excel(here::here('data', 'US_State_Wind_Energy_Facts_2018.xlsx'))\n\nglimpse(wind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 50\n#> Columns: 7\n#> $ Ranking                         <chr> \"1.0\", \"2.0\", \"3.0\", \"4.0\", \"5.0\", …\n#> $ State                           <chr> \"TEXAS\", \"OKLAHOMA\", \"IOWA\", \"CALIF…\n#> $ `Installed Capacity (MW)`       <dbl> 23262, 7495, 7312, 5686, 5110, 4464…\n#> $ `Equivalent Homes Powered`      <chr> \"6235000.0\", \"2268000.0\", \"1935000.…\n#> $ `Total Investment ($ Millions)` <chr> \"42000.0\", \"13700.0\", \"14200.0\", \"1…\n#> $ `Wind Projects Online`          <dbl> 136, 45, 107, 104, 35, 49, 98, 31, …\n#> $ `# of Wind Turbines`            <chr> \"12750.0\", \"3717.0\", \"4145.0\", \"697…\n```\n\n\n:::\n:::\n\n\n\n\n\nHere we see that many variables that should be numeric are actually characters (e.g. `Ranking`, `Equivalent Homes Powered`, `Total Investment ($ Millions)`, and `# of Wind Turbines`).\n\nTo address this, one of the first things we usually do is convert incorrect data types to the appropriate ones, like this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwind <- read_excel(here::here('data', 'US_State_Wind_Energy_Facts_2018.xlsx')) %>%\n  mutate(\n    Ranking = as.numeric(Ranking),\n    `Equivalent Homes Powered` = as.numeric(`Equivalent Homes Powered`),\n    `Total Investment ($ Millions)` = as.numeric(`Total Investment ($ Millions)`),\n    `# of Wind Turbines` = as.numeric(`# of Wind Turbines`)\n  )\n    \nglimpse(wind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 50\n#> Columns: 7\n#> $ Ranking                         <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …\n#> $ State                           <chr> \"TEXAS\", \"OKLAHOMA\", \"IOWA\", \"CALIF…\n#> $ `Installed Capacity (MW)`       <dbl> 23262, 7495, 7312, 5686, 5110, 4464…\n#> $ `Equivalent Homes Powered`      <dbl> 6235000, 2268000, 1935000, 1298000,…\n#> $ `Total Investment ($ Millions)` <dbl> 42000, 13700, 14200, 12600, 9400, 8…\n#> $ `Wind Projects Online`          <dbl> 136, 45, 107, 104, 35, 49, 98, 31, …\n#> $ `# of Wind Turbines`            <dbl> 12750, 3717, 4145, 6972, 2795, 2632…\n```\n\n\n:::\n:::\n\n\n\n\n\n::: {.callout-important}\n\nBe careful converting strings to numbers!\n\n:::\n\nIf you use `as.numeric()` (as we did above), you can get NAs if there are any non-numeric characters in the data. For example:\n\n::: {.grid}\n\n::: {.g-col-6}\n\nThis works great:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas.numeric(c(\"2.1\", \"3.7\", \"4.50\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2.1 3.7 4.5\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.g-col-6}\n\nThe `$` symbol breaks this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nas.numeric(c(\"$2.1\", \"$3.7\", \"$4.50\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] NA NA NA\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\n\nA solution is to use `parse_number()` instead, which parses strings for numbers:\n\n::: {.grid}\n\n::: {.g-col-6}\n\nThis works great:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparse_number(c(\"2.1\", \"3.7\", \"4.50\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2.1 3.7 4.5\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.g-col-6}\n\nThe `$` symbol breaks this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparse_number(c(\"$2.1\", \"$3.7\", \"$4.50\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2.1 3.7 4.5\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\n### Fixing variable names\n\nYou might also notice that the variables names in the `wind` dataset are long and messy:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwind <- read_excel(here::here('data', 'US_State_Wind_Energy_Facts_2018.xlsx'))\n\nnames(wind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Ranking\"                       \"State\"                        \n#> [3] \"Installed Capacity (MW)\"       \"Equivalent Homes Powered\"     \n#> [5] \"Total Investment ($ Millions)\" \"Wind Projects Online\"         \n#> [7] \"# of Wind Turbines\"\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can easily fix these with `janitor::clean_names()`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(janitor)\n\nwind <- read_excel(here::here('data', 'US_State_Wind_Energy_Facts_2018.xlsx')) %>%\n  clean_names()\n\nnames(wind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"ranking\"                   \"state\"                    \n#> [3] \"installed_capacity_mw\"     \"equivalent_homes_powered\" \n#> [5] \"total_investment_millions\" \"wind_projects_online\"     \n#> [7] \"number_of_wind_turbines\"\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can even specify the style of the names:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(janitor)\n\nwind <- read_excel(here::here('data', 'US_State_Wind_Energy_Facts_2018.xlsx')) %>%\n  clean_names(case = 'lower_camel')\n\nnames(wind)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"ranking\"                 \"state\"                  \n#> [3] \"installedCapacityMw\"     \"equivalentHomesPowered\" \n#> [5] \"totalInvestmentMillions\" \"windProjectsOnline\"     \n#> [7] \"numberOfWindTurbines\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Using `select()` to rename and reorder variables\n\nHere's an example data set on the sleeping patterns of different mammals:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nglimpse(msleep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 11\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater s…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"c…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"…\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.…\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0…\n```\n\n\n:::\n:::\n\n\n\n\n\nThe primary use of `select()` is to choose which columns to **keep** or drop:\n\n\n::: {.grid}\n\n::: {.g-col-6}\n\nSelecting variables to **keep**\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  select(name:order, sleep_total:sleep_cycle) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 7\n#> $ name        <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater sh…\n#> $ genus       <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"B…\n#> $ vore        <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"ca…\n#> $ order       <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"A…\n#> $ sleep_total <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0,…\n#> $ sleep_rem   <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.8…\n#> $ sleep_cycle <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333,…\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.g-col-6}\n\nSelecting variables to **drop**\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  select(-(name:order)) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 7\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.…\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0…\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\nWe can also select columns based on **partial column names**\n\nFor example, we can select columns that start with \"sleep\":\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  select(name, starts_with(\"sleep\")) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 4\n#> $ name        <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater sh…\n#> $ sleep_total <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0,…\n#> $ sleep_rem   <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.8…\n#> $ sleep_cycle <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333,…\n```\n\n\n:::\n:::\n\n\n\n\n\nOr we can select columns that contain \"eep\" and end with \"wt\":\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  select(contains(\"eep\"), ends_with(\"wt\")) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 5\n#> $ sleep_total <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0,…\n#> $ sleep_rem   <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.8…\n#> $ sleep_cycle <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333,…\n#> $ brainwt     <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000,…\n#> $ bodywt      <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0.…\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also use `select()` to select columns based on their **data type**\n\n::: {.grid}\n\n::: {.g-col-6}\n\nSelect only **numeric** columns:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n    select_if(is.numeric) %>%\n    glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 6\n#> $ sleep_total <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0,…\n#> $ sleep_rem   <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.8…\n#> $ sleep_cycle <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333,…\n#> $ awake       <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0,…\n#> $ brainwt     <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000,…\n#> $ bodywt      <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0.…\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n\n::: {.g-col-6}\n\nSelect only **character** columns:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n    select_if(is.character) %>%\n    glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 5\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater s…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"c…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"…\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\nYou can also use `select()` to **reorder** variables. The key is to use `everything()`, which tells R to keep all the other variables in the data frame. \n\nFor example, if we wanted to move the `conservation` and `awake` variables to the first two columns, we could do this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n    select(conservation, awake, everything()) %>%\n    glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 11\n#> $ conservation <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", NA, \"d…\n#> $ awake        <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9, 21.0…\n#> $ name         <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Greater s…\n#> $ genus        <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bos\", \"…\n#> $ vore         <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi\", \"c…\n#> $ order        <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorpha\", \"…\n#> $ sleep_total  <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1, 3.0…\n#> $ sleep_rem    <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.6, 0.…\n#> $ sleep_cycle  <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.3833333…\n#> $ brainwt      <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.07000…\n#> $ bodywt       <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.490, 0…\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also use `select()` to **rename** variables. \n\nThe pattern here is `new = old`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  select(\n    animal = name,\n    extinction_threat = conservation\n  ) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 2\n#> $ animal            <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Grea…\n#> $ extinction_threat <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", N…\n```\n\n\n:::\n:::\n\n\n\n\n\nNotice however that this drops everything else. \n\nIf you wanted to just rename them but keep all other variables, use `rename()`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmsleep %>%\n  rename(\n    animal = name,\n    extinction_threat = conservation\n  ) %>%\n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> Rows: 83\n#> Columns: 11\n#> $ animal            <chr> \"Cheetah\", \"Owl monkey\", \"Mountain beaver\", \"Grea…\n#> $ genus             <chr> \"Acinonyx\", \"Aotus\", \"Aplodontia\", \"Blarina\", \"Bo…\n#> $ vore              <chr> \"carni\", \"omni\", \"herbi\", \"omni\", \"herbi\", \"herbi…\n#> $ order             <chr> \"Carnivora\", \"Primates\", \"Rodentia\", \"Soricomorph…\n#> $ extinction_threat <chr> \"lc\", NA, \"nt\", \"lc\", \"domesticated\", NA, \"vu\", N…\n#> $ sleep_total       <dbl> 12.1, 17.0, 14.4, 14.9, 4.0, 14.4, 8.7, 7.0, 10.1…\n#> $ sleep_rem         <dbl> NA, 1.8, 2.4, 2.3, 0.7, 2.2, 1.4, NA, 2.9, NA, 0.…\n#> $ sleep_cycle       <dbl> NA, NA, NA, 0.1333333, 0.6666667, 0.7666667, 0.38…\n#> $ awake             <dbl> 11.9, 7.0, 9.6, 9.1, 20.0, 9.6, 15.3, 17.0, 13.9,…\n#> $ brainwt           <dbl> NA, 0.01550, NA, 0.00029, 0.42300, NA, NA, NA, 0.…\n#> $ bodywt            <dbl> 50.000, 0.480, 1.350, 0.019, 600.000, 3.850, 20.4…\n```\n\n\n:::\n:::\n\n\n\n\n\n## Recoding Variables\n\n### Recoding with `ifelse()`\n\nThe `ifelse()` function takes the pattern:\n\n```\nif <condition>, <value if condition is TRUE>, <value if condition if FALSE>\n```\n\nExample: Create a variable, `cost_high`, that is `TRUE` if the repair costs were greater than the median costs and `FALSE` otherwise.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwildlife_impacts1 <- wildlife_impacts %>%\n  rename(cost = cost_repairs_infl_adj) %>%\n  filter(!is.na(cost)) %>%\n  mutate(\n    cost_median = median(cost),\n    cost_high = ifelse(cost > cost_median, TRUE, FALSE)\n  )\n\nwildlife_impacts1 %>%\n  select(cost, cost_median, cost_high) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 3\n#>     cost cost_median cost_high\n#>    <dbl>       <dbl> <lgl>    \n#> 1   1000       26783 FALSE    \n#> 2    200       26783 FALSE    \n#> 3  10000       26783 FALSE    \n#> 4 100000       26783 TRUE     \n#> 5  20000       26783 FALSE    \n#> 6 487000       26783 TRUE\n```\n\n\n:::\n:::\n\n\n\n\n\n### Recoding with **nested** `ifelse()`\n\nOften times you may want to make a category variable that takes different values based on different conditions. You can \"nest\" multiple `ifelse()` statements to achieve this.\n\nFor example, let's say we wanted to create a variable, `season`, based on the `incident_month` variable. We could do this like so:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwildlife_impacts2 <- wildlife_impacts %>%\n  mutate(season = ifelse(\n    incident_month %in% c(3, 4, 5), 'spring', ifelse(\n    incident_month %in% c(6, 7, 8), 'summer', ifelse(\n    incident_month %in% c(9, 10, 11), 'fall', 'winter')))\n  ) \n\nwildlife_impacts2 %>%\n  distinct(incident_month, season) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 2\n#>   incident_month season\n#>            <dbl> <chr> \n#> 1             12 winter\n#> 2             11 fall  \n#> 3             10 fall  \n#> 4              9 fall  \n#> 5              8 summer\n#> 6              7 summer\n```\n\n\n:::\n:::\n\n\n\n\n\nHere we're entering into another `ifelse()` statement as the \"else\" condition of an earlier condition. \n\n### Recoding with `case_when()`\n\nYou can achieve the same thing as the example about usin ghte `case_when()` function, which produces slightly cleaner code.\n\n**Note**: If you don't include the final `TRUE ~ 'winter'` condition, you'll get `NA` for those cases.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwildlife_impacts2 <- wildlife_impacts %>%\n  mutate(season = case_when(\n    incident_month %in% c(3, 4, 5) ~ 'spring',\n    incident_month %in% c(6, 7, 8) ~ 'summer',\n    incident_month %in% c(9, 10, 11) ~ 'fall',\n    TRUE ~ 'winter')\n  ) \n\nwildlife_impacts2 %>%\n  distinct(incident_month, season) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 2\n#>   incident_month season\n#>            <dbl> <chr> \n#> 1             12 winter\n#> 2             11 fall  \n#> 3             10 fall  \n#> 4              9 fall  \n#> 5              8 summer\n#> 6              7 summer\n```\n\n\n:::\n:::\n\n\n\n\n\n### Recoding with `case_when()` and `between()`\n\nHere's another approach to achieve the same thing but using the `between()` function to note any months between a start and end month:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwildlife_impacts2 <- wildlife_impacts %>%\n  mutate(season = case_when(\n    between(incident_month, 3, 5) ~ 'spring',\n    between(incident_month, 6, 8) ~ 'summer',\n    between(incident_month, 9, 11) ~ 'fall',\n    TRUE ~ 'winter') \n  )\n\nwildlife_impacts2 %>%\n    distinct(incident_month, season) %>%\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 2\n#>   incident_month season\n#>            <dbl> <chr> \n#> 1             12 winter\n#> 2             11 fall  \n#> 3             10 fall  \n#> 4              9 fall  \n#> 5              8 summer\n#> 6              7 summer\n```\n\n\n:::\n:::\n\n\n\n\n\n### Break a single variable into two with `separate()`\n\nThe `tb_rates` data set contains information on tuberculosis rates in different countries. It looks like this:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntb_rates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 3\n#>   country      year rate             \n#>   <chr>       <dbl> <chr>            \n#> 1 Afghanistan  1999 745/19987071     \n#> 2 Afghanistan  2000 2666/20595360    \n#> 3 Brazil       1999 37737/172006362  \n#> 4 Brazil       2000 80488/174504898  \n#> 5 China        1999 212258/1272915272\n#> 6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can break the `rate` variable into two separate variables, `cases` and `population`, using the `separate()` function:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntb_rates %>%\n  separate(rate, into = c(\"cases\", \"population\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also specify the separator:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntb_rates %>%\n  separate(\n      rate,\n      into = c(\"cases\", \"population\"),\n      sep = \"/\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   country      year cases  population\n#>   <chr>       <dbl> <chr>  <chr>     \n#> 1 Afghanistan  1999 745    19987071  \n#> 2 Afghanistan  2000 2666   20595360  \n#> 3 Brazil       1999 37737  172006362 \n#> 4 Brazil       2000 80488  174504898 \n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also convert the new variables to numeric by adding `convert = TRUE`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntb_rates %>%\n  separate(\n    rate, \n    into = c(\"cases\", \"population\"),\n    sep = \"/\", \n    convert = TRUE\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> # A tibble: 6 × 4\n#>   country      year  cases population\n#>   <chr>       <dbl>  <int>      <int>\n#> 1 Afghanistan  1999    745   19987071\n#> 2 Afghanistan  2000   2666   20595360\n#> 3 Brazil       1999  37737  172006362\n#> 4 Brazil       2000  80488  174504898\n#> 5 China        1999 212258 1272915272\n#> 6 China        2000 213766 1280428583\n```\n\n\n:::\n:::\n\n\n\n\n\n## Dealing with Dates Data\n\nDates are notoriously annoying to deal with.\n\n<center>\n<img src=\"images/dates.png\" width=500>\n</center>\n\n### Create Dates from Strings\n\nTo deal with dates, we'll use the `lubridate` package. \n\n::: {.callout-note}\n\nCheck out the `lubridate` **[cheat sheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)**\n\n:::\n\nThe key concept to remember with `lubridate` is:\n\n**order is the ONLY thing that matters!**\n\nThe package has special functions that convert date strings into formal date formats. The function names are based on the order of the date:\n\n::: {.grid}\n\n::: {.g-col-4}\n\nYear-Month-Day\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd('2020-02-26')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\nymd('2020 Feb 26')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\nymd('2020 Feb. 26')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\nymd('2020 february 26')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.g-col-4}\n\nMonth-Day-Year\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmdy('February 26, 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy('Feb. 26, 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmdy('Feb 26 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n::: {.g-col-4}\n\nDay-Month-Year\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndmy('26 February 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy('26 Feb. 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndmy('26 Feb, 2020')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2020-02-26\"\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n\n:::\n\n### Extracting information from dates\n\nThe `today()` function returns the current date:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndate <- today()\ndate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2025-12-10\"\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can extract different components of the date using the `year()`, `month()`, and `day()` functions:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyear(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2025\n```\n\n\n:::\n\n```{.r .cell-code}\nmonth(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 12\n```\n\n\n:::\n\n```{.r .cell-code}\nday(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also get the month name in a specific format using the `month()` function:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmonth(date, label = TRUE, abbr = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] December\n#> 12 Levels: January < February < March < April < May < June < ... < December\n```\n\n\n:::\n:::\n\n\n\n\n\nYou can also get the weekday name in a specific format using the `wday()` function:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nwday(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(date)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nwday(date, label = TRUE, abbr = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] Wed\n#> Levels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n```\n\n\n:::\n:::\n\n\n\n\n\nThe same functions can also be used to modify elements of dates:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndate <- today()\ndate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2025-12-10\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change the year\nyear(date) <- 2016\ndate \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2016-12-10\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Change the day\nday(date) <- 30\ndate\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"2016-12-30\"\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}